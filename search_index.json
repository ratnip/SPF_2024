[["index.html", "Let’s program in R (“Statistical Programming Fundamentals” course book) Foreword", " Let’s program in R Damir Pintar 2024-10-06 (“Statistical Programming Fundamentals” course book) ** NOTE: During the current academic year, the “Statistical Programming Fundamentals” is revised chapter by chapter. After the subject is New chapters will be dynamically added to this HTML document. If you need to have access to all the materials, contact the author of the tutorial at damir.pintar@fer.hr** Foreword This tutorial is based on interactive lessons used in the “Statistical Programming Fundamentals” at the Faculty of Electrical Engineering and Computing at the University of Zagreb. But the topics discussed here are not only useful to the students of the mentioned faculty - knowledge of the language R will be good both in academia and in the business world. Although R is known as a “programming language made up of statisticians, for statisticians” and is most often associated with the field of data science within which it is used for complex statistical analysis and data mining, it can be very useful for tasks related to the management of smaller or larger data at tasks that are not necessarily strictly oriented to advanced analytics. Namely, popular graphical tools with their interactive tabular presentation are very intuitive and excellent for simpler tasks, but as the need for more complex tasks appears, they quickly lose their efficiency and simplicity; on the other hand, the interactive program approach offered by R is initially somewhat more demanding but long-term highly cost-effective because complex tasks can be dealt with in an efficient, consistent and insightful way. For this reason, in the business world there is a clear shifting trend from classic GUI office tools to platforms with better support for more complex calculations and the creation of attractive visualizations. This is evidenced by a strong increase in the popularity of R language and other platforms with similar approach to data analysis. The aforementioned popularity of R language results in an increased need for learning resources, which are not currently very much present in Croatia. This coursebook will try to make learning R as easy and interesting as possible through its “learning through examples” approach. Emphasis will be placed primarily on mastering R as a programming language. For this reason, the initial chapters will focus on “programmatical aspects”, followed by a review of available tools presumed to be useful for the widest set of readers - tools for data gathering, extracting useful information, and visualizations. Since R is a domain-oriented language, R’s role in its support for statistical analysis will be reviewed followed byexamining selected machine learning methods and their applications. Although there will be enough information to put all the presented methods into context, the idea of this textbook is not to teach readers statistics nor deeply enter the field of machine learning - the intention of the author is to intrigue readers to continue exploring this interesting area, adequately armed with platform knowledge that will enable all new knowledge is immediately practically applied in further research. "],["introduction.html", "1 Introduction 1.1 What is R? 1.2 Installing Software Support 1.3 Overview of the development interface RStudio 1.4 How to use this coursebook?", " 1 Introduction 1.1 What is R? 1.1.1 General facts about R Programming language R came from the programming language S, developed for the needs of Bell Telephone Laboratory owned by AT &amp; T corporation. It was designed as an internal statistical analysis tool. The basic philosophy of the S language (inherited by the programming language R) was domain orientation - ie facilitating work with data analysts without the need to adapt conventions to traditional programming languages. Language S gained significant popularity in business analysts and statisticians within the 80s and 90s, but is now only available through a commercial variant called S-PLUS. The programming language R was created at the University of Auckland (NZ) and is released under the GNU Open Code Code. The standard distribution of the R programming language consists of: “core” R, with basic functions and so called “core” base package that provides basic functionality a collection of additional packages (“base” - base and “recommended” - recommended) for data management, visualization and statistical analysis We must not ignore the excellent integration of R with a rich repository called CRAN (Comprehensive R Archive Network) that enables fast and easy installation of any packet from that repository, after which it becomes part of the local R installation. Since the R community is extremely productive when it comes to the development of new packages, often after the introduction of new experimental methods and algorithms, CRAN quickly offers packages that implement them. Also, strong and continuous enthusiasm of the R community for the enhancement of existing R elements alleviates or eliminates a large number of various deficiencies of the base language. R as a language can often be seen as a DIY project of sorts where, after getting acquainted with the supplied “factory” components (in this case basic functions and packages), the user begins to adapt his development environment by choosing a package that exactly matches their needs and preferences. Creativity and flexibility in using R is considered to be of great advantage, even though it may result in a certain informality and liberal approach to programming. This is occasionally not favoured by users from a more strict and formal programming background, used to having a clear set of guidelines and rules to be followed. Despite the exceptionally high acceptance of the R language for data analysis and the variety of options offered to the user, it is necessary to be aware of some of its limitations: R intensely uses RAM which has been considered a serious restriction for a long time. With the increase of the memory capacity in modern hardware systems, as well as the rise of processing engines which can integrate with R and relieve it of the intense memory requirements when it comes to large datasets, this limitation is much less important today. Still, the fact remains that R can quickly hog the available RAM of your machine, though it is often the result of the neglect or ignorance of a developer who has not adopted the “R” approach when it comes to programming, opting to leverage patterns borrowed from other programming languages which result in suboptimal R code. R is quite unconventional so the learning curve is initially steeper, especially for programmers accustomed to standard conventions of other programming languages. On the other hand, if viewed long-term, programming in R eventually becomes very quite simple and user-friendly since most of the complex tasks are abstracted into high-level functions that transparently perform low-level operative tasks. It is often said that R is more focused towards the goal we want to achieve and cares less about the exact way to reach it. R is not a “fast” language; although it is a language that is expected to work over large data sets, R is not optimized for performance speed or even for parallelism; although there is a great deal of effort to implement virtually all key routines in C which prevents significant slowdowns, and there are a number of packages that offer support for multithreading, the fact remains that R is not designed to have its scripts get executed as quickly as possible; If speed is a priority, it is often necessary to look for alternative solutions - which is why it is often said that R is primarily a research language, not a production language. R is primarily intended for interactive work, i.e. performing a series of machine instructions that are dynamically executed with the help of a program console. This is tailored to the standard process of data analysis where the analyst can download data, clean it, transform, develop models, test, etc. while getting continuous feedback from a computer, providing the opportunity to dynamically adapt the analysis process. This does not mean that programming language can not be programmed in a classical “procedural” way by developing algorithms encapsulated in functions that automatically perform their tasks after being called, however where R truly shines is while performing interactive tasks. This principle is also reflected when it comes to learning R; it’s a programming language which is much easier to learn through the interactive approach of performing specific, goal-oriented tasks, experimenting with data sets, trying out data exploration methods, and so on, rather than using a “classic” approach by designing scripts that implement some low-level programming jobs. 1.1.2 R alternatives Programming Language R is a popular but not the only solution for interactive data analysis and statistical programming. Below we will give a brief overview of some of the more popular technologies and solutions used today for this purpose, with a brief comparison and a review of the advantages and disadvantages compared to language R. SAS and SPSS - SAS (Statistical Analysis System, developed by SAS Institute) and SPSS (Software Package for Statistical Analysis, developed by IBM) are two different software packages that we put under the same paragraph primarily because they are commercial tools, ie tools that require full payment for their full functionality. Similarly, SAS and SPSS are relatively easy to learn and their functionality is largely based on carefully designed user interfaces. These tools emphasize efficiency and are an excellent option for large companies looking for a consistent, robust solution for their analytics, not bothered by the commercial nature of such solutions. Weka and Orange - Weka (Waikato Environment for Knowledge Analysis, developed by Waikato University in New Zealand) and Orange* (deep data analysis software developed at the University of Ljubljana) are free software for exploratory data analysis and data mining that base their functionality on relatively simple graphing interfaces and visual programming approach. These solutions are very good for users who are not too demanding in terms of the flexibility and complexity of their analysis because they allow the implementation of defined steps in the analysis process in a very accessible and clear way. This does not mean that these tools can not do more complex analysis, but they are still more suited to analyses through the predefined functionality of the provided graphical interface. Python (Numpy / Pandas / Scikit) - in the last couple of years, Python is the most serious competitor of language R, primarily because Python is a very popular programming language with a very similar process approach to data analysis compared to one used by language R. The discussion of which language to choose is very common in the field of data science, usually without a clear final conclusion. The actual differences are not as big as those discussions may make it seem - while R is strongly domain-oriented and emphasis is placed on ease of use with a wide range of available overlapping packages to enable the user to choose the one that best suits him, Python emphasizes the rigid formal structure and principle “for one job one way of doing”. Therefore, it could be said that R is somewhat more suitable for “data research” while Python’s advantage is easier development and integration of analytical modules in a production environment, especially if said environment is already implemented in Python. But with the strong development of both languages and the mutual overlapping of functionality, this distinction becomes less relevant - it is no longer a problem to integrate R scripts into existing systems regardless of the platform they are running on, and the Python community is developing its versions of popular packages from R that faithfully emulate their functionality. Ultimately, it can be said that the initial choice between these two alternatives is not so important - the approach they use is so similar and the functionality sharing is so pronounced that learned concepts are easily transferable between both languages. It also must be said that the RStudio environment allows for mixing Python and R code in a single report, further closing the divide between these languages. Rapidminer - this is a cloud-based data science software platform that provides an integrated environment for data preparation, machine learning, deep learning, text mining, and predictive analytics. It is used for business and commercial applications as well as for research, education, training, rapid prototyping, and application development and supports all steps of the machine learning process including data preparation, results visualization, model validation and optimization. Rapidminer is primarily template-based, however it is possible to write extensions for it using R or Python. 1.2 Installing Software Support Installing the R language support software is pretty simple, especially if the recommended development interface RStudio is used as a platform. This is not the only option - one of the popular alternatives is the multilingual platform Jupyter Notebook which offers its own R support. Readers are encouraged to explore all available options and choose the final selection of the interface that personally matches their needs best; however this coursebook strongly recommends choosing RStudio mainly because of a clear, user-friendly and functionality-rich interface, easy installation and a very rich support for a variety of functionalities - from installing new packages, easy retrieval of documentation, creating visualizations and publishing reports, to integrating with other data science-related software. Therefore the rest of the coursebook will assume that readers are using the RStudio IDE. To successfully set up R software, you need to install the following: R language distribution RStudio integrated development environment It is recommended to use the latest available versions. At the time of writing this book, they are R 4.0 and RStudio 1.3. If these versions differ from those on your computer, there will probably be no problem if the version numbers are higher than the above; otherwise, their upgrade is recommended. The procedure for installing this software on the operating system Microsoft Windows will be described below. If you are working on some other operating system, such as a Linux distribution or Mac OS, the procedure is somewhat different, but still not too complex - it’s enough to do a web search focused on installing R and RStudio on a particular OS and follow further instructions. To find the software mentioned in the search engine, type the following terms: download R download RStudio In both cases, you will get links to the executable files that you have to run to install the software on your computer. In the case of R, this can be a file R-4.2.2-win.exe (exact numbers may differ). In the interface RStudio you can see more options - choose a free “desktop” version. Commercial versions have some additional functionalities that are mostly oriented to use in professional multi-user environments and are not essential to normal work. You can run the executable files and let the wizard install all the necessary components on your computer. It is recommended to accept all of the default installation options except for the choice of the installation folder - instead of the subfolder Program Files “it is better to install R directly in the root folder (eg”C:\\R\\R-4.2.2”), if possible. This way, it will be easier to check the currently installed version and potentially update it later. For the same reason, it is recommended that RStudio be installed in the folder “C:\\R\\RStudio”. If you do not have the option or you do not want to choose these folders, you can use others or leave the default options - this choice should not ultimately affect the further work. After installing RStudio it is highly recommended you create a separate subfolder where you will be doing most of your R related work (for example, folder “C:\\R\\projects”). After launching RStudio, the application should look similar to the following image: Figure 1.1: RStudio interface layout If there are any problems, make sure that you have completed all of the installation steps listed above. Below we will deal with the details of the interface shown. Before continuing, you might consider creating a new “project” (File -&gt; New Project -&gt; New Directory) and create a project called “IntroToR” in the projects folder mentioned above. You can then later put all the resources related to this course in this project folder. When you want to open RStudio and continue working on tasks from this course, it will be enough to double-click the IntroToR.Rproj file in the above subfolder, or choose the “IntroToR” project in the upper right corner of the screen. 1.3 Overview of the development interface RStudio Let’s look at the interface RStudio. We see it is being divided into three windows - the left part is the “work area” with the programming console, waiting for us to enter instructions. On the right, there are auxiliary windows that show different things, depending on the selected tab; In the upper right hand corner, we can see, among other things, variables in our current working environment (which is initially empty). We can also choose to see command history, control connections to other data storage and analysis software etc.. The bottom part serves to display documentation, file structures, installed packages, visualizations, etc. 1.3.1 Interactive console Let’s go back to the left part of the interface, the “interactive console”. R, by its nature, is an “interpreter language” in the sense that the programming console expects from the user to enter commands which are then immediately interpreted and executed. Though it is possible to create larger scripts that are then executed “all at once”, working with the R language often boils down to using command-by-command principle. This is precisely why we are talking about “data analysis via interactive programming” - the analyst is “programming” by entering commands and can at any time study the obtained results, deciding on further steps. Let’s see how the interactive console works. With the help of a keyboard, you can type a simple math expression - eg 3 + 2 - and press the ENTER key. We will see that R will immediately deliver the result - if we want, we can easily use it as a calculator! For mathematical expressions that do not have predefined operator symbols we need to use functions. For example, a square root can be calculated using the sqrt () function. Let’s try typing sqrt(10) in the console and pressing ENTER. R again shows the result immediately. At this point, the screen should look like the next picture. Figure 1.2: R as a calculator One of the problems of using R this way is the messy mixing of commands and results, not allowing us an easy high-level overview of the sequence of commands we were performing. Furthermore, if for some reason the command that we execute results in an error (and we then keep trying to correct it by entering the proper command), the console soon becomes cluttered with error reports. This is why analysts often prefer using “R scripts” that allows for entering commands in a separate place before sending them to the console, visually distinguishing the procedure we want to execute with the obtained results gained after the planned instructions are executed. 1.3.2 Writing R scripts In the toolbar, select File -&gt; New File -&gt; R Script (or press the CTRL + SHIFT + N key combination). We see that the “working area” on the left becomes divided into two parts. The upper part represents the space for our “script” - actually the series of commands we want to execute - while the interactive console now occupies the lower part of the work surface. If we want, we can tweak the size of these (and other windows) by moving the bordering bars between them. Also, there’s an easy way of switching the focus between the two, through the usage of CTRL + 1 and CTRL + 2 key combinations. Try to write two simple commands in the scripting window - the first one should be print(\"hello!\") And underneath it a simple mathematical expression 3 + 4. Return the cursor to the first line and press the CTRL + ENTER key combination. If we have correctly followed these steps, the command at the cursor site will automatically be copied to the interactive console and executed. The cursor will now be the next command that you can do with CTRL + ENTER. The screen should now look similar to the next image. Figure 1.3: R script This is one of the common ways of working in RStudio- first we create some programming instructions in the script space, after which we send them to the console. If something is wrong with the command, we can easily modify it and perform it again. If you want to execute a block of commands, you can select them by clicking and dragging and then pressing the CTRL + ENTER key. Scripts can also contain comments (starting with the # character that R interprets as “ignore this line”). Finally, we can store our scripts in a file - by convention, R scripts have a simple extension R, for example myScript.R. However, we can go one step further. Despite the fact that the R scripts are quite adequate for comfortable work in the R language, there is an additional technology that gives us even more flexibility in working with the R - R Markdown. 1.3.3 R Markdown Writing R scripts is very similar to the classic concept of “programming” - we write commands that are (usually) executed sequentially, and optionally we add comments for the purpose of the documentation. However, data analysis process commonly involves dissemination of results via data science reports, either for the analysts themselves or to the intended audience. RStudio interface supports a technology that provides an effective combination of programming and structured documentation using the principle of “interactive notebooks”. Interactive notebooks allow the user to combine formatted text (optionally with formulas and figures) with executable code, and text formatting, and then insert executable code, ending up with a format resembling a notebook. For this RStudio uses the R Markdown technology, as well as its slightly updated cousin, R Notebook. Since the differences between these two are relatively superficial, we will focus on the slightly simpler one R Markdown. This technology is easiest to demonstrate via example - in the toolbar, select File -&gt; New File -&gt; R Markdown ... and in the next window choose an arbitrary title (eg \"Testing\"). You can optionally edit the metadata, such as add the author’s name, and finally choose one of the options for final form of report (HTML is recommended due to its lowest dependency on additional software). Unlike the R script, which will initially appear empty, when creating an RMD document RStudio will create a new pre-filled document. This is done in this way for the simple reason that the user gets an easily modifiable template with all the basic elements included as a reminder. We will delete most of this template for our needs - so feel free to remove everything after the initial header, i.e. below the second ---. Then, we can write any text below. We can also experiment with headers which start with #, ##, ### characters - these are NOT “R comments”, since we are now not programming, we are writing formatted text. By using * and ** characters in front and back of the words we can make letters become bold and italicized, respectively. Everything mentioned so far in this paragraph is pure “markdown”, which basically means “plain text with added formatting information that can be converted into formatted text with the help of additional tools, if desired”. When we want to incorporate executable code into our “report”, we need to create so-called “code chunks”. This can be done by selecting Insert -&gt; R on the toolbar or using the CTRL + ALT + I combination of keys. Notice that the chunk begins and ends with a specially selected string of characters - three so called “backticks” (they look like simple apostrophes, but are angled towards the left). Likewise, the beginning of the chunk contains description of certain parameters in the opening brackets, which can affect the way RStudio is processing this “code chunk”, most notably by having us state which programming language we will use. In this coursebook, we will almost exclusively use the language R, although other options are available if they had been previously installed on the platform running RStudio. The code chunk behaves the same as the standard R script - we can enter commands and execute them. The difference is just that the results can be seen immediately in the R Markdown document itself (in addition to them showing up in the console). If this is not something that we want, we can turn this functionality off (click on the gear in the toolbar and select Chunk output in console), however we usually prefer to have the results right below the code that created them, notebook-style. If we follow the instructions, the screen may look similar to the following image: Figure 1.4: R Markdown document We can now try to create a “report” from the current document. First, we must save it under a particular name (eg Testing.rmd), and then we can click on the Knit button to convert the document from pure text to an HTML file. (Note - if our platform is missing some packages, we will see that in the warning toolbar which will show up - we just need to pick the option “Install” and wait until RStudio downloads the required packages from the CRAN repository) R Markdown documents are much more powerful than it may seem judging by the elements that have been presented so far. Chunks can have plenty of different parameters which influence their behaviour. The output format can be PDF, DOCX as well as other forms such as presentation slides, books intended for mobile devices, interactive web applications etc. The coursebook you are reading is actually nothing more than a series of RMD files converted into the appropriate form you are currently using. As we will explain in the next chapter, RMD files are also the main way for you to use this coursebook effectively and try out the examples and tasks that follow. The universality and flexibility of technology R Markdown is exceptionally great, and is very well accepted by the R community. 1.4 How to use this coursebook? The basic idea of this coursebook is “learning through application”. Therefore, the lessons below will not focus on merely showing and talking about new concepts, but rather encouraging the reader to learn out each new concept by solving a series of easy or intermediate tasks. Each chapter that follows has an accompanying “workbook”. Simply put, it is an RMD file that contains all the examples from the lecture, accompanied by a concise text for easier reference to the concepts being dealt with. The basic idea is that the reader reads the coursebook and solves the workbook in parallel, looking at the task solution only after it is solved within the programming interface. Some exercises will be trivial, require simply removing the # sign (meaning “comment”) from the start of the command and executing it. In spite of the trivial approach, in this way, however, the reader is encouraged to independently test the command rather than just look at its result. Other exercises will be a bit more involved. Each exercise will also have a solution underneath (which will be hidden if using the interactive version of the coursebook). Readers are encouraged to only look at the solution after first solving the exercise themselves. Finally, each chapter will end with a set of additional exercises which will not have accompanying. It is recommended to successfully solve all these exercises, since the lessons that follow presume the well-accepted knowledge of all the topics that are discussed previously (and some exercises will sneakily introduce some helpful functions or tricks which may become very useful later on). Let’s get to know the concept of workbooks more closely. First, you need to download and open a workbook that matches the lesson you are reading. It is easy to recognize it by looking at the chapter number - the notebook for this chapter should be named 01_Introduction_WB.Rmd. It is recommended that all workbooks that you plan to use are copied somewhere to the local computer together with all the accompanying files, and then perhaps create a backup copy of the original workbook (since solving a workbook will change its contents). As stated previously, the workbook will typically contain all the program code in the chapter to which it refers, but usually only the minimal amount of text sufficient for easier understanding and solving the exercises. Workbooks will leverage two types of tasks: Examples and Exercises. Examples will be pieces of code that will just need to be executed, without any modification. Exercises on the other hand expect at least some changes, and often require entering completely new segments of program code. An Example might look like this: Example 1.1 - a few simple mathematical expressions 3 + 2 # adding log(10) # natural logarithm! log10(10) # this is a base-10 logarithm! By the way, we comment with the &quot;#&quot; sin(0.5 * pi) # pi is one of the built-in constants ## [1] 5 ## [1] 2.302585 ## [1] 1 ## [1] 1 You can execute the commands from the examples individually, or the entire chunk at once with the CTRL + SHIFT + ENTER key combination. No modification of the code is necessary (although you should always feel free to experiment further with the given commands, either in the chunk itself or in the console!). As stated, Exercises on the other hand always require a certain - even minimal - intervention. Exercise 1.1 - Commands for checking/changing the working directory # Make the following commands by removing the comment character #getwd() # current working directory #setwd(&quot;.&quot;) # here we can specify a new working folder if desired # usually not a good idea when working with RMD files getwd() # directory in which we are currently working setwd(&quot;.&quot;) # here we can specify a new working folder if desired # usually not a good idea when working with RMD files The exercise will often be related to the most recently introduced concept. For example, we might be learning the assignment operator, and explaining that although language R supports the usage of = operator for assigning a value to a variable, it is recommended to use the &lt;- operator for that purpose, for various reasons to be explained later (use ALT + - to quickly write &lt;-). Also, note that R supports the so-called autoprint functionality, when a command or a set of commands is executed, the value of the last expression will be shown on screen. This means that if we create a new variable x and want to print it on the screen, we do not have to put print(x)as the last command, but rather just x. Also, using an assignment operator does not return a value in itself, which is why we do not see anything printed out on screen after assigning a value to a variable. Let’s try to experiment with these concepts in the following exercise. Exercise 1.2 - Assignment operator # store `5` in a variable called `x` # then print the variable `x` on the screen x &lt;- 5 x ## [1] 5 Now that we have some basic knowledge about language R and the programming interface we will be using, we can begin by learning the basic elements of the R programming language. Programirajmo u R-u by Damir Pintar is licensed under a Creative Commons Attribution-NonCommercial-NoDerivatives 4.0 International License.Based on a work at https://ratnip.github.io/FER_OPJR/ "],["tipovi.html", "2 Basic data types and operators 2.1 Basic data types 2.2 Operators 2.3 Missing, unknown, and non-existent values Homework exercises", " 2 Basic data types and operators “Basic” or “primitive” types of data are the underlying building blocks of programming languages. They are basically embedded mechanisms that allow storing basic information - most commonly of logical, numeric, or character nature. Most programming languages use very similar methods of storing such information, which means that we can expect to see similar basic data types in almost every programming language - the difference is often in certain implementation specifics such as the name of the basic type, the default number of bytes is uses etc. In any case, the most common first step in learning a new programming language is getting to know the basic types of data that it supports. The next thing that may interest us is the language syntax, that is, the specific way programming instructions are written so the programming language can adequately interpret them and execute. The R language syntax follows similar conventions seen in languages such as Python, Ruby, or Java, but with its own specifics. Some basic syntax rules are: each command must, as a rule, go to its own line, but the indentation and semicolons at the end are optional; programming blocks are delinated with brackets; variables types need not be declared in advance, their type is inferred based on the assigned value; comments start with #; etc. The rest of the syntax will be best learned through examples. We will start with basic operators and functions and work from there. 2.1 Basic data types R offers six basic data types: type examples logical TRUE, FALSE ili T, F integer 2L, 5L, 123456789L double 4, 6, 3.14, 2e5 complex 5 + 2i, 7 + 1i character \"A\", \"B\", \"Pero\", \"ABCDEFGHijklmnoPQRSTUVwyz\" raw as.raw(2), charToRaw(\"1\") Some remarks: integer and real types are often treated together as a numeric type (although this is not entirely consistent!) complex type must have a declared imaginary constant even if it is 1 (2 + i is not a good record!) The type of “raw” bytes is relatively rarely used Checking whether a variable is of a certain type can be done with the help of is.&lt;type_name&gt; functions. Before we get to test this function in the upcoming exercise, we will introduce one small trick: in exercises where we print more things on the screen, it is useful to visually separate the different result segments so that we can easily understand which part of the code is referenced. For this purpose, we will use the cat(\"-----------\\n\") command that simply prints a dashed line followed with the newline character. We opted for this solution instead of simply using the “empty” print(\"\") function because that function always prints out the index of the result as well as the string quotation marks, while the cat command is just a “raw” print, which is in this case more appropriate. Exercise 2.1 - checking data types # try the following commands: #is.logical(FALSE) #is.integer(2L) #is.double(1.11) # perform the following checks: # is 5L numeric? # is 3.14 numeric? # is &quot;ABC&quot; character? # is 4 + 2i complex? # is 5 integer? # try the following commands: is.logical(FALSE) is.integer(2L) is.double(1.11) cat(&quot;-----------\\n&quot;) # perform the following checks: # is 5L numeric? is.numeric(5L) # is 3.14 numeric? is.numeric(3.14) # is &quot;ABC&quot; character? is.character(&quot;ABC&quot;) # is 4 + 2i complex? is.complex(4 + 2i) # is 5 integer? is.integer(5) ## [1] TRUE ## [1] TRUE ## [1] TRUE ## ----------- ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] TRUE ## [1] FALSE Types of some variables or constants can be retrieved with the help of typeof orclass functions. The difference between these functions is the following: typeof answers to the question “in which underlying format is this variable stored?”; hence, it will return the “primitive” or “basic” type ( integer, double) class answers to the question “what IS this variable?”; it will return the “object type”, which is actually the value stored in the class attribute of this variable Exercise 2.2 - data type retrieval # print the types of the following constants: TRUE, 2L, F, 3.14, &quot;ABC&quot; # print the classes of the same constants. Do you see any differences? # print the types of the following constants: TRUE, 2L, F, 3.14, &quot;ABC&quot; typeof(TRUE) typeof(2L) typeof(F) typeof(3.14) typeof(&quot;ABC&quot;) cat(&quot;-----------\\n&quot;) # print the classes of the same constants. Do you see any differences? class(TRUE) class(2L) class(F) class(3.14) class(&quot;ABC&quot;) ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;double&quot; ## [1] &quot;character&quot; ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;integer&quot; ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;character&quot; Data can be explicitly converted from one type to another using the functions as.&lt;type_name&gt;: Exercise 2.3 - conversion of data types # perform the following conversions and print the result # 2.35 to integer # TRUE to ntomeric # 100L to character # 2.35 to character # 2e2 to character # 0 to logical # 2.75 to logical # perform the following conversions and print the result # 2.35 to integer as.integer(2.35) # TRUE to ntomeric as.numeric(TRUE) # 100L to character as.character(100L) # 2.35 to character as.character(2.35) # 2e2 to character as.character(2e2) # 0 to logical as.logical(0) # 2.75 to logical as.logical(2.75) ## [1] 2 ## [1] 1 ## [1] &quot;100&quot; ## [1] &quot;2.35&quot; ## [1] &quot;200&quot; ## [1] FALSE ## [1] TRUE R will always perform an implicit conversion of types if possible: Exercise 2.4 - implicit conversion # Write the following phrases and print the results: # arithmetic operator between logical and numeric variables # arithmetic operator between integer and numeric variables # logical operator negation (!) applied to numeric variable # arithmetic operator between logical and numeric variables TRUE + 5 # arithmetic operator between integer and numeric variables 5L + 3.14 # logical operator negation (!) applied to numeric variable !25 ## [1] 6 ## [1] 8.14 ## [1] FALSE Implicit conversion will only be performed if it is meaningful - for example, we cannot perform arithmetic operations between a character type and a numeric type. 2.2 Operators As in other programming languages, R allows using various operators when forming expressions. Some of the more frequently used operators are: arithmetic +, -, *, /, ^, %% (division reminder), %/% comparison &lt;, &lt;=, &gt;, &gt; =, ==, != logical ! (negation), &amp;&amp; (scalar AND), || (scalar OR), &amp; (vector AND), | (vector OR) assignment &lt;- or= Exercise 2.5 - operators # try the `5 / 2` and` 5 %/% 2` expressions # calculate the &quot;square of 17&quot; and &quot;the remainder of 101 divided by 12&quot; # check what is the result of the following expressions: `17 &gt; 13`,`!TRUE`, `5 &amp;&amp; 0`,`0. || 2` # try the `5 / 2` and` 5 %/% 2` expressions 5 / 2 5 %/% 2 cat(&quot;-----------\\n&quot;) # calculate the &quot;square of 17&quot; and &quot;the remainder of 101 divided by 12&quot; 17 ^ 2 101 %% 12 cat(&quot;-----------\\n&quot;) # check what is the result of the following expressions: `17 &gt; 13`,`!TRUE`, `5 &amp;&amp; 0`,`0. || 2` 17&gt; 13 ! TRUE 5 &amp;&amp; 0 0. || 2 ## [1] 2.5 ## [1] 2 ## ----------- ## [1] 289 ## [1] 5 ## ----------- ## [1] TRUE ## [1] FALSE ## [1] FALSE ## [1] TRUE Logical values and comparison operators will most commonly be used with the conditional expressions, better known as “if-else” commands. In R, the syntax of such commands looks like this: if (expression) {block} else {block} Let’s try this on the following task: Exercise 2.6 - conditional expressions # Write a command that performs the following: # &quot;if 100 is an even number print &#39;Success!&#39;&quot; # Write a command that performs the following: # &quot;if 100 is an even number print &#39;Success!&#39;&quot; if (100 %% 2 == 0) print(&quot;Success!&quot;) ## [1] &quot;Success!&quot; We have noted above that we have two types of logical operators for “and” and “or”. We will explain the difference later, for now it is enough to know that instructions that control the program flow exclusively use the “C++”-like operators &amp;&amp; i ||. Before, we have already mentioned that R offers two assignment operators, &lt;- and =. There are some minor differences, but those mostly pertain on using these operators in other contexts - when used purely for assigning a result of an expression to a new variable, their functionality is almost identical. In the literature, both versions can be seen for assigning values, but we will primarily and consistently use &lt;-, if nothing than because that way the code is visually more distinctive from code from the other programming languages. NOTE: an easy way to type in the &lt;- operator is to press the keys ALT and - The operands in the expression that uses the assignment operator are called the “lvalue” (left value) and “rvalue” (right value), respectively. Rvalue is an expression that needs to be calculated, while the left (lvalue) is interpreted as “the place where the result of the expression on the right will be stored”. This means that examples like this x + 1 &lt;- 2 # error !!!] do not work - it is not unambiguous what is being stored where. Therefore, as a rule, the lvalue is most commonly a (new or existing) variable, though in some occasions we will actually be seeing a function call. This may appear confusing, but there is a perfectly intuitive explanation for this which we will bring later. Naming the variables mostly follows the rules from other programming languages, with some slight peculiarities - we can use letters, numbers, underscores and dots (the dot . is treated like a regular character!). The first symbol must be a letter or a dot. .myVarijable &lt;- 5 #OK my.Variable &lt;- 5 #OK _myVariable &lt;- 5 # not OK 123Variable &lt;- 5 # not OK If we use variable names which consist of multiple words, it is customary tp pick one of the following conventions: myVariable &lt;- 1 # camelcase my_Variable &lt;- 2 # underscore seperation or my.variable &lt;- 3 # point separation Sticking consistently to one of these choice will result in a nicer, more readable code. R also allows a way to go around the variable-naming conventions, and to use any printable character in a variable name. If we want to use this functionality, we then must put this name inside “backticks”: Exercise 2.7 - variable name with special characters # Enter an arbitrary name with special characters inside the left apostrophes # and print the value of the variable # `` &lt;- 2 # Enter an arbitrary name with special characters inside the left apostrophes # and print the value of the variable # `` &lt;- 2 `!% ^$*@ __ =` &lt;- 2 `!% ^$*@ __ =` ## [1] 2 This way of naming variables is not too useful in practice, but it has its purpose - since the operators in R are actually functions (whose names are literally +, ^ etc.), by using left backticks we can directly reference them in their original form, which can be very practical in the so-called functional programming (which we will talk about in one of the future lessons). Assigning values to new variable names results in creation of new variables in the working environment (called the “global environment”). All variables we have created so far can be seen with the ls() function. If we want to delete some variables, we just provide their names in the call function rm(), without quotation marks (e.g. rm (x, y, z)). To delete all variables from the working environment, we can use the call rm(list=ls()), but this should be done with caution (there’s no “undo”!). Exercise 2.8 - printing and deleting global environment variables # print all of the global environment variables that have been created so far # delete some of the above variables - eg rm(x, y, z) # list all remaining variables # delete ALL variables from the global environment # (cautiously with this call in practice!) # Make sure the global environment is empty # print all of the global environment variables that have been created so far ls() # delete some of the above-written variables - eg rm(x, y, z) # list all remaining variables rm(x, y) ls() # delete ALL variables from the global environment # (cautiously with this call in practice!) # Make sure the global environment is empty rm(list=ls()) ls() Finally, whenever we need help with some function, we have the following options available: write only &lt;function_name&gt; (without parenthesis with parameters) and press - if the function is written in R (and not just proxy to a C implementation) the screen will print the original source code of the function Write help(&lt;function_name&gt;) or ?&lt;function_name&gt; to get a documentation page with the list of parameters, examples, and so on. Write example(&lt;function_name&gt;) where we get a list of examples of using said function The following code chunk shows how to use the above methods (to save space, we will not show the result, but feel free to try out these commands in the console). #program code for `ls` function ls # help for `ls` function ?ls # or help(ls) # examples of using the `ls` function example(ls) 2.3 Missing, unknown, and non-existent values In R there are three ways of modeling “non-existent” values: NA - (not available) - for missing or unknown values of a particular type NaN - (not a number) - “impossible” number, e.g. 0 / 0 NULL - non-existent value, literally “nothing” NaN is a subclass of NA. The difference between NA and NULL is subtle, but important. NA means that the value is possibly there, we just don’t know what it is. NA values still have a type, so an unknown numeric value is still numeric. NULL on the other hand is a placeholder for “nothing” - it is its own class, and it denotes that whatever we are referencing is empty. One important note for SQL users - what is NULL in SQL is NA in R. Do not be mixing SQL’s NULL and R’s NULL, since they are usually completely different things! Exercise 2.9 - working with NA, NaN and NULL # how much is &quot;5 + unknown number&quot; # how much is &quot;5 + non-existent number&quot; # check classes of the following: # NA # arithmetic operation between numeric and NA # NaN # NULL # how much is &quot;5 + unknown number&quot; 5 + NaN # how much is &quot;5 + non-existent number&quot; 5 + NA cat(&quot;-----------\\n&quot;) # check classes of the following: # NA # arithmetic operation between numeric and NA # NaN # NULL class(NA) # logical type is &quot;weakest&quot;! class(5 + NA) class(NaN) class(NULL) ## [1] NaN ## [1] NA ## ----------- ## [1] &quot;logical&quot; ## [1] &quot;numeric&quot; ## [1] &quot;numeric&quot; ## [1] &quot;NULL&quot; Checking missing values is similar to checking data types - we use the is.na,is.nan and is.null functions. Exercise 2.10 - check NA, NaN and NULL # which of the following is NA? NA, NaN, NULL, &quot;&quot;, 0 # which of the following is NaN? NA, NaN, NULL # which of the following is NULL? NA, NaN, NULL # which of the following is NA? NA, NaN, NULL, &quot;&quot;, 0 is.na(NA) is.na(NaN) is.na(NULL) is.na(&quot;&quot;) is.na(0) cat(&quot;-----------\\n&quot;) # which of the following is NaN? NA, NaN, NULL is.nan(NA) is.nan(NaN) is.nan(NULL) cat(&quot;-----------\\n&quot;) # which of the following is NULL? NA, NaN, NULL is.null(NA) is.null(NaN) is.null(NULL) ## [1] TRUE ## [1] TRUE ## logical(0) ## [1] FALSE ## [1] FALSE ## ----------- ## [1] FALSE ## [1] TRUE ## logical(0) ## ----------- ## [1] FALSE ## [1] FALSE ## [1] TRUE To end, we dedicate some room to a discussion of the NA value, since we will often encounter it in practice. Simply put, if the NA values appear, we can expect the following side effects: results of arithmetic expressions which contain NA as operands will result in NA values the results function calls which get NA as parameters can result with NA (but sometimes there is an option to use the parameter na.rm = T which actually means ‘ignore NA values’) logical expressions which contain NA may or may not necessarily result in a NA value, depending on whether the term depends on NA or not (eg TRUE || NA has the result of TRUE, but FALSE || NA has the result NA) With this last one, we must be especially careful as the NA in the conditional term results in a mistake: if (NA &lt; 2) print (&quot;Success!&quot;) # error !! In this lesson we have learned the basic elements of the language R. However, in practice, we much more often work with complex data types - vectors, matrices, data frames and lists - which are the subject of the following lesson. Homework exercises What is the result of the following commands? Try to predict the result before executing each command. as.complex(2) as.integer(-3.25) as.logical(&quot;0&quot;) as.numeric(TRUE) as.character(11.5 + 2i) as.numeric(&quot;ABC&quot;) How do the following expressions look like in R: “ten to the power of nine multiplied by 3” “natural logarithm of 5” “integer division of 10 by 3” “the remainder of integer division of 10 by 3” “tangent of 75 degrees” R has a special constant for “infinity”. Try to find what it is by using an arithmetic expression. Then, by using if, check whether reducing “infinity” from “infinity” results in a NaN value. Store NULL in a variable called x. Then try to convert this variable into a numeric type. Explain what you think has happened (full explanation will be given in the following chapter). Program in Ru &lt;/ span&gt; by Damir Pintar is licensed under Creative Commons Attribution-NonCommercial-NoDerivative 4.0 International License Based on a work at https://ratnip.github.io/FER_OPJR/ "],["vektori.html", "3 Vectors, matrices and lists 3.1 Vector 3.2 Index vectors 3.3 Matrices and arrays 3.4 Lists Homework exercises", " 3 Vectors, matrices and lists 3.1 Vector The vector is the primary “complex” data types in the language R, in the sense that it can contain more values of the same type. It is similar to the term “array” in the C language. However, there is one important difference, which may be not immediately obvious. Unlike C, R does not really have “basic data types”, even though the last chapter may have given the impression it is so. In R, (almost) each variable type is actually a vector. Even the variables and constants we were showing in the previous lesson were actually single-element vectors. This revelation has far-reaching consequences to be discussed in detail below, but before delving into specifics we first need to get acquainted with the basic syntax of creating and managing vectors. 3.1.1 Creating a vector When we want to create a new vector variable which stores more then one value we must use the function simply named c (from combine or concatenate). # numeric vector m &lt;- c(1, 2, 3, 4, 5) # logic vector v &lt;- c(T, F, T) # character vector names &lt;- c(&quot;Ivo&quot;, &quot;Pero&quot;, &quot;Ana&quot;) So, simply stated, a vector is an arranged set of elements of the same type. If we create a new vector with elements of different types, R will automatically convert all elements into the “strongest” type, which will eventually become the type of vector itself (the term “stronger” type in this context means the type able to store everything without any loss of information which might happen if it was stored in a “weaker” type). Generally the conversion goes in the direction of logic -&gt; numeric -&gt; character types. Exercise 3.1 - creating vectors # create a new vector `x` with four arbitrary elements of the following types: # logical, double, character and integer # print the vector content and its class on screen # create a new vector `x` with four arbitrary elements of the following types: # logical, double, character and integer x &lt;- c(T, 1.25, &quot;Ivo&quot;, 10L) # print the vector content and its class on screen x class(x) ## [1] &quot;TRUE&quot; &quot;1.25&quot; &quot;Ivo&quot; &quot;10&quot; ## [1] &quot;character&quot; A vector can be explicitly converted to another type with the help of as.&lt;type_name&gt; functions, already introduced in the previous chapter. If unambiguous conversion is impossible, the element will be converted to NA, and the conversion will be accompanied with a suitable warning. Exercise 3.2 - explicit vector type conversion x &lt;- c(1, T, 2L) y &lt;- c(1L, 2L, 3L) z &lt;- c(1.25, TRUE, &quot;Ana&quot;) # consider what might be the result first, and then perform the following conversions # vector `x` in numeric type # vector `y` in character type # vector `z` in an integer type x &lt;- c(1, T, 2L) y &lt;- c(1L, 2L, 3L) z &lt;- c(1.25, TRUE, &quot;Ana&quot;) # consider what might be the result first, and then perform the following conversions # vector `x` in numeric type # vector `y` in character type # vector `z` in an integer type as.numeric(x) as.character(y) as.integer(z) ## Warning: NAs introduced by coercion ## [1] 1 1 2 ## [1] &quot;1&quot; &quot;2&quot; &quot;3&quot; ## [1] 1 NA NA Think about why in the last example the value TRUE became NA instead of 1L that you might have expected. If you cannot figure out the reason, try to print the z vector itself and notice the results of the implicit conversion you might have neglected (which converts the TRUE logical value to a string of \"TRUE\" that can no longer be interpreted as its logical counterpart, which would otherwise result in the numeric value 1L). 3.1.2 Vector concatenation Remember that we said c can mean “combine elements” but also concatenate? With the c function we can also concatenate multiple vectors to one: a &lt;- c(1, 2, 3) b &lt;- c(4, 5) c &lt;- c(6, 7, 8) # variable can be called &quot;c&quot; in spite of the function c() d &lt;- c(a, b, c) # d is now c(1, 2, 3, 4, 5, 6, 7, 8) When creating vectors, we are not confined to exclusively using the c function. In addition to it, R also offers multiple convenient ways of creating new vectors: : - “range” operator, giving the range from upper to lower bound, both included seq - sequence function, similar to the range operator but with additional options rep - replicate function, repeats the provided elements a certain number of times Exercise 3.3 - vector creation helper functions # print the results of the following commands # 1:5 # rep(c(1, 2, 3), times = 3) # rep(c(1, 2, 3), each = 3) # seq(1, 5, by = 0.5) # print the results of the following commands 1:5 rep(c(1, 2, 3), times = 3) rep(c(1, 2, 3), each = 3) seq(1, 5, by = 0.5) ## [1] 1 2 3 4 5 ## [1] 1 2 3 1 2 3 1 2 3 ## [1] 1 1 1 2 2 2 3 3 3 ## [1] 1.0 1.5 2.0 2.5 3.0 3.5 4.0 4.5 5.0 Vectors can also be created by means of functions corresponding to the names of the vector types (numeric,character, etc.) whereby as a parameter we specify the desired length of the vector. This is often done as a “storage preparation” for the elements which will subsequently be filled in. If the length is not zero, the vector will be filled with the chosen number of appropriate zero-equivalents, depending on the actual type. Interestingly, we can also create an “empty” vector of a certain type, and it will still be considered a vector, only having the length of zero (and by using the c function we can easily add elements to it later). x &lt;- numeric(2) # vector is filled with &quot;zero&quot; elements, in this case (0, 0) y &lt;- character(5) z &lt;- integer(0) # &quot;empty&quot; vector! z &lt;- c(z, 1) # add to the vector the element 1 (actually &quot;merge empty vector and element 1&quot;) It is sometimes possible to get a zero-length vector as a result of an expression - for example, this often happens in conjunction with a NULL value, where the expression adds a type to literally “nothing”, resulting in an vector which is empty but still has a certain type. Finally, to check if some vector contains a certain element we can use the operator %in%: 4 %in% seq(1, 10, 2) # returns FALSE &quot;d&quot; %in% c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;) # returns TRUE We learned how to create vectors, now let’s see how we can access their elements. 3.1.3 Operator [ The vector element is accessed through the index operator [, with which we can retrieve but also modify vector elements: a &lt;- c(2, 4, 6) a[1] # prints a value of 2 a[2] &lt;- 5 # element on the 2nd place becomes 5 a[5] &lt;- 7 # we add 7 to the 5th place, and the &quot;hole&quot; is filled with NA a ## [1] 2 ## [1] 2 5 6 NA 7 Notice a somewhat unusual fact - the first element of the vector in R has the index 1, not 0! This is an important difference compared to the indexing of elements in most other programming languages. The reason for this peculiarity is simple - R is primarily a language for data analysis, and when referring to data, especially in tabular form. When data analysts refers to their data, it is much easier to count rows or columns in order they appear in a data set than to constantly do a mental “add 1” calculation - so the first row is always “row 1”, never “row 0”, even though someone from programming background would readily recognize it as such. The example above actually shows a very simplified case for retrieving vector elements and modifying them. However, there is an extremely important feature of language R called vectorization, that - informally speaking - states that R often prefers doing “more things at once”. This has nothing to do with parallel execution of tasks, but rather with the declarative approach to defining tasks which would in other languages require low-level programming, most commonly using loops. Specifically, in the case of referencing vector elements, we rarely retrieve or modify elements one by one, but rather we refer to multiple elements at once using the principles of vectorization and recycling. Understanding these terms is crucial for learning the R language, so we will explain them in detail below. 3.1.4 Principles of vectorization and recycling The notion of vectorization or more precisely vectorized operator and functions simply means that most operator and functions by design work on multiple elements at once. If we ask R to make an operation or function over a vector of values, R will perform the function or operation over each element separately and package the results in a new, resulting vector. Likewise, if we use a binary operator on two vectors as operands, the corresponding operation will be performed over the “paired” or “aligned” elements of both vectors (supposing for now that the vectors are of the same length). Let’s demonstrate this in the following exercise. Exercise 3.4 - vectorization principle x &lt;- seq(-5, 5, 1) a &lt;- 1:3 b &lt;- 4:6 # call the abs function to calculate the absolute value # over the vector `x` and print the result # add vectors `a` and` b` with operator `+` # and print the result # multiply vectors `a` and `b` with operator `*` # and print the result # call the abs function to calculate the absolute value # over the vector `x` and print the result abs(x) cat(&quot;-----------\\n&quot;) # add vectors `a` and `b` with operator `+` # and print the result a + b cat(&quot;-----------\\n&quot;) # multiply vectors `a` and `b` with operator `*` # and print the result a * b ## [1] 5 4 3 2 1 0 1 2 3 4 5 ## ----------- ## [1] 5 7 9 ## ----------- ## [1] 4 10 18 Carefully consider the results of the previous task. If necessary, draw representations of the vector a and b on paper (with the elements arranged vertically) and notice how R does the “pairing” of the elements. Notice also that we are not really talking about “vector operations” here in a strict mathematical sense, but about aligning the elements of two vectors and performing simple operations over each of these pairs. This is especially evident in the last example where there is no “vector multiplication” in some of the mathematical interpretations, but rather simple multiplication of the parallel elements of the two vectors. What if the vectors are not of the same length? R in this case uses the principle of recycling. The Recycling Principle states that when the vectors are not of the same length, the shorter vector is “recycled” as many times as needed to reach the length of the longer vector. The most common scenarios of using this principle are operations where on one side we have a vector with multiple elements and on the other a single-element vector. What we should be trying to avoid though is a recycling scenario where the length of a “big” vector is not a multiple of the “small” length - R will still recycle a shorter vector, only it will have to be “cut off”, which will result in an appropriate warning. Exercise 3.5 - recycling principle a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep(5, 3) # multiply vector `a` with the number 2 and print the result # divide vector `a` with vector `b` and print the result # multiply vectors `a` and `c` and print the result a &lt;- 1:4 b &lt;- c(1, 2) c &lt;- rep(5, 3) # duplicate vector `a` and print the result 2 * a # divide vector `a` with vector `b` and print result a / b # multiply vectors `a` and `c` and print the result a * c ## Warning in a * c: longer object length is not a multiple of shorter object ## length ## [1] 2 4 6 8 ## [1] 1 1 3 2 ## [1] 5 10 15 20 Now we can finally demystify the difference between “scalar” and “vector” logical operators. scalar logical operators &amp;&amp; and || are intended for use with single-element vectors, they return unique values of TRUE or FALSE and are suitable for use in various conditional terms. vector logical operators &amp; and | use standard R’s vectorization and recycling principles, i.e., they are intended to work with logical vectors and as a result give a logical vector Exercise 3.6 - scalar and vector logical operators a &lt;- c(T, F, F) b &lt;- c(T, T, F) # apply scalar and vector version of logical operator &quot;or&quot; # over the `a` and `b` vectors and print the result # apply scalar and vector version of logical operator &quot;or&quot; # over the `a` and `b` vectors and print the result #a || b # error! a | b ## [1] TRUE TRUE FALSE We see that the scalar version will “use” only the first pair of logic vector elements. This means while it could theoretically be used conditional expressions, there is no justifiable reason for it, and R will in this case warn us to address the fact that we are probably using the “wrong” operator. The next example with the relational operators may initially seem trivial, but it is important to pay special attention to the results we get since they will have very important implications later on. Let’s take a look what happens when vectorization is applied in conjunction with relational operators. Exercise 3.7 - vectorization of relational operators x &lt;- 1:5 y &lt;- seq(-10, 10, 5) # print x and y # print the result of the x &gt; y command and explain the result # print the result of the x &lt; 3 command and explain the result # print x and y x y cat(&quot;-----------\\n&quot;) # print the result of the x &gt; y command and explain the result x&gt; y cat(&quot;-----------\\n&quot;) # print the result of the x &lt; 3 command and explain the result x &lt; 3 ## [1] 1 2 3 4 5 ## [1] -10 -5 0 5 10 ## ----------- ## [1] TRUE TRUE TRUE FALSE FALSE ## ----------- ## [1] TRUE TRUE FALSE FALSE FALSE Thus, by vectorizing the relational operators over the vectors (or combinations of vectors and scalars), as a result we get logical vectors. The interpretation of these results is crucial - it actually answers the question “on what positions is the condition of this expression fulfilled”? In other words, the results actually represent a template that describes how to filter elements of a vector based on a filtering expression. This is the basic foundation of the so-called. logical indexing, which is one of the vector indexing methods that we will learn below. 3.2 Index vectors We have already learned that a vector can be retrieved with a help of a numerical index (and we did not forget the fact that the first element has an index 1). This concept can be expanded by taking multiple elements from the vector at once. which is often referred to as “slicing”. The basic principle of choosing multiple elements at once is simple - we only need to specify the indexes of the elements we want. R offers three basic ways of indexing: integer- or position-based indexing conditional or boolean-based indexing label-based indexing Which indexing we choose depends on whether we want to access the elements based on their position, name, or condition, and each type of indexing essentially amounts to using a particular vector type as a parameter for the indexing operator. Such a vector is then called an “index vector”, based on its role in the expression. Let’s get to know each of the types of indexing in detail. 3.2.1 Positional Indexing Positional Indexing is the generalization of an already familiar indexing principle where we simply write the numeric position (index) of the element we are interested in. If we want more elements, we simply put their indices “packed” into a numeric vector. Try solving the next exercise by using the appropriate numeric vectors as indexing parameters. Exercise 3.8 - Positional indexing x &lt;- 1:10 # print the first element of the vector `x` # print the first three elements of the vector `x` # print the first, fifth, and seventh elements of the vector `x` # print the first element of the vector `x` x[1] # print the first three elements of the vector `x` x[1:3] # print the first, fifth, and seventh elements of the vector `x` x[c(1,5,7)] ## [1] 1 ## [1] 1 2 3 ## [1] 1 5 7 Thus, the positional index vector is simply the ordinary numeric vector we use in conjunction with the index operator [ to determine which elements of another vector we want to “keep”. Let’s look at some of the features of the positional index vector: Exercise 3.9 - Positional indexing (2) x &lt;- 1:10 # answer the following questions with the help of an appropriate example # what does index 0 return? # what does a negative index return? # what happens if you use an index outside of vector boundaries x &lt;- 1:10 # answer the following questions with the help of an appropriate example # what does index 0 return? x[0] # what does a negative index return? x[-1] # what happens if you use an index outside of vector boundaries x[20] ## integer(0) ## [1] 2 3 4 5 6 7 8 9 10 ## [1] NA Indexing is not only used to retrieve elements. By combining the indexing operator and the assignment operator we can change the vector elements (also leveraging the principle of “doing more things at once”): Exercise 3.10 - Positional indexing and assignment a &lt;- 1:10 # set all vector elements of `a` from the second to the eighth place to zero # print vector `a` b &lt;- 1:20 b [2 * 1:5] &lt;- 0 # Consider what the vector `b` looks like after the above command # print the vector `b` and explain the result a &lt;- 1:10 # set all vector elements of `a` from the second to the eighth place to zero # print vector `a` a [2:8] &lt;- 0 a b &lt;- 1:20 b [2 * 1:5] &lt;- NA # Consider what the vector `b` looks like after the above command # print the vector `b` and explain the result b ## [1] 1 0 0 0 0 0 0 0 9 10 ## [1] 1 NA 3 NA 5 NA 7 NA 9 NA 11 12 13 14 15 16 17 18 19 20 3.2.2 Conditional indexing If we carefully considered the results obtained with examples with vectorized relational operators then we can very easily grasp the way conditional indexing works. The principle is simple - for the index vector we choose a logical vector of the same length as the vector whose elements we want to retrieve. The elements of this logical vector determine which elements are retained (the positions where the value is TRUE) and which we throw out (positions where the value is FALSE). Exercise 3.11 - conditional indexing x &lt;- 1:10 # create a logical vector `y` of length 10 with an arbitrary combination of # TRUE and FALSE values # index the vector `x` with the `y` vector, print and explain the result # print all vector elements `x` which are less or equal to 5 # use the appropriate expression as a logical index vector x &lt;- 1:10 # create a logical vector `y` of length 10 with an arbitrary combination of # TRUE and FALSE values y &lt;-c(T, T, F, T, F, F, F, T, F, T) # index the vector `x` with the `y` vector, print and explain the result x[y] # print all vector elements `x` which are less or equal to 5 # use the appropriate expression as a logical index vector x[x &lt;= 5] ## [1] 1 2 4 8 10 ## [1] 1 2 3 4 5 The last command, while simple, is one of the key principles for filtering elements in the language R. The combination of the index operator and the conditional expression represents a concise but very powerful vector filtering mechanism. Let’s try this principle in a few more examples. Exercise 3.12 - conditional indexing y &lt;- seq (1, 100, 7) students &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # print a vector which contains all even, and then all odd vector elements of `y` # (&quot;odd&quot; and &quot;even&quot; refers to element&#39;s value, not position) # print all vector elements from `students` which represent 3-letter names # (note: we use the `nchar` function to count the characters in R) y &lt;- seq (1, 100, 7) students &lt;- c(&quot;Ivo&quot;, &quot;Petra&quot;, &quot;Marijana&quot;, &quot;Ana&quot;, &quot;Tomislav&quot;, &quot;Tin&quot;) # print a vector which contains all even, and then all odd vector elements of `y` # (&quot;odd&quot; and &quot;even&quot; refers to element&#39;s value, not position) c(y[y %% 2 == 0], y[y %% 2 != 0]) # print all vector elements from `students` which represent 3-letter names # (note: we use the `nchar` function to count the characters in R) students[nchar(students) == 3] ## [1] 8 22 36 50 64 78 92 1 15 29 43 57 71 85 99 ## [1] &quot;Ivo&quot; &quot;Ana&quot; &quot;Tin&quot; If the concept of conditional indexing with the help of conditional expressions is still unclear, one of the things that can help is to sketch the intermediate results - simply print the result of the expression within the indexing brackets and then consider how that result affects the final solution. 3.2.3 Label-based indexing Label-based indexing works on the principle of explicitly naming the elements we want to “keep”. In order to be able to use this type of indexing though we must ensure one necessary prerequisite - we need to first assign names to our vector elements. The vectors we used so far did not have named elements. Each element had its predefined position within the vector and its value but did not have any additional special identifiers. Programming language R allows you to attach names to vector elements in a very simple way - by using a combination of the names function, the assignment operator, and the character vector with selected names. We need to make sure however that the vector name is of the same length as the original vector. Exercise 3.13 - label-based indexing height &lt;- c(165, 173, 185, 174, 190) names(height) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # print the vector `height` # print the height of Pero and Josip height &lt;- c(165, 173, 185, 174, 190) names(height) &lt;- c(&quot;Marica&quot;, &quot;Pero&quot;, &quot;Josip&quot;, &quot;Ivana&quot;, &quot;Stipe&quot;) # print the vector `height` height # print the height of Pero and Josip height[c(&quot;Pero&quot;, &quot;Josip&quot;)] ## Marica Pero Josip Ivana Stipe ## 165 173 185 174 190 ## Pero Josip ## 173 185 We see that label-based indexing needs a corresponding character vector as the index parameter. (NOTE: A more careful reader will notice an unusual fact in the above code - it uses a function call as an lvalue! Understanding why this is possible requires some slightly advanced knowledge about the inner workings of the R language. For now it is enough to know that the above exercise isn’t really calling a function called names, but rather a function called names&lt;-, a member of a special kind of “assignment” functions which allow using the intuitive and easily readable syntax seen above) If for some reason we want to delete the names of vector elements, simply forward NULL to names(&lt;vector_name&gt;). names(height) &lt;- NULL This will conclude the story of the index vectors. We learned different ways of creating a vector and getting and modifying its elements. Now is the time to try to add the additional “dimension” to the vectors - by getting acquainted with matrices and the arrays. 3.3 Matrices and arrays Out simply - the matrices and the arrays are what you get when you add more dimensions to vectors. Matrix is a two-dimensional vector, i.e. a vector whose elements are organized in “rows” and “columns”. Array is a vector with three or more dimensions. While matrices are used relatively often in practice, the arrays are somewhat limited to very specific use cases. Because of this fact in this chapter we will mainly deal with matrices, although the concepts presented are very easily applicable to arrays too. One common thing about the matrices and arrays, which is a well-known fact to readers who come from programming backgrounds, is that their multidimensionality is actually completely virtual. Both the matrix and the array are actually one-dimensional vectors and it’s only the usage of multidimensional indices which allows these structures to behave as if they are truly multidimensional. On other words, when the programmer uses a multidimensional index, R simply maps it to the “real”, one-dimensional index of the element in the underlying one-dimensional vector. This fact is not limiting in the slightest though - programmatically, we can still in most cases treat the matrix as if it is truly a two-dimensional structure; the knowledge of its underlying one-dimensional nature can only give us additional flexibility in working with the matrices, and also allows us to write better code. There are several ways to create a new matrix: by fitting a one-dimensional vector inside a matrix structure: we use the matrix function with this one-dimensional vector as a parameter, followed by the desired number of rows and/or columns provided through the nrow and ncol parameters “manually” by setting the “dimension attribute” of a one dimensional vector using the dim function with a given two-element numeric vector for dimensions “binding” rows or columns together with functions rbind (row-bind) and cbind (column-bind) Let’s try to see this in action in the following exercise. Exercise 3.14 - the matrix function x &lt;- 1:12 # create a matrix with 3 rows and 4 columns using the `matrix` function # print the result on the screen # repeat the procedure but add the parameter `byrow = T` to the calling function # print the result on the screen and compare it to the previous result # create a matrix with 3 lines and 4 columns using the `matrix` function # print the result on the screen matrix(x, nrow = 3, ncol = 4) # repeat the procedure but add the parameter `byrow = T` to the calling function # print the result on the screen and compare it to the previous result matrix(x, nrow = 3, ncol = 4, byrow = T) ## [,1] [,2] [,3] [,4] ## [1,] 1 4 7 10 ## [2,] 2 5 8 11 ## [3,] 3 6 9 12 ## [,1] [,2] [,3] [,4] ## [1,] 1 2 3 4 ## [2,] 5 6 7 8 ## [3,] 9 10 11 12 Note that unless explicitly requested otherwise, the R matrix is always filled by columns. This is done mostly because in data analysis we usually perform operations by columns. But since we often feel that filling by the rows is more “natural”, we must not forget the option of using the very useful parameter byrow. Exercise 3.15 - the dim function m &lt;- 1:10 # print the result of call of the `dim` function to the vector `m` (checking the dimensions) # use the `dim` function on vector`m` with the parameter `c(2, 5)` # print `m` and comment the result # print the results of calling functions `nrow` and` ncol` on the matrix `m` m &lt;- 1:10 # print the result of call of the `dim` function to the vector `m` (checking the dimensions) dim(m) # use the `dim` function on vector`m` with the parameter `c(2, 5)` dim(m) &lt;- c(2, 5) # print `m` and comment the result m # print the results of calling functions `nrow` and` ncol` on the matrix `m` nrow(m) ncol(m) ## NULL ## [,1] [,2] [,3] [,4] [,5] ## [1,] 1 3 5 7 9 ## [2,] 2 4 6 8 10 ## [1] 2 ## [1] 5 We see that the “ordinary” vector does not actually have a dimension, which is manifested by the NULL values we get as a result when asking for it. By invoking the function dim we can add the similarly called attribute dim which formally turns this vector into a matrix (or array in a general case). Provided dimensions dictate how the elements are (virtually!) organized in rows and columns, which means that when choosing the dimensions we must take care they correspond to the current number of elements. Once the matrix has its dimensions added, we can retrieve them again by using the dim function, or just the number of rows or columns with the nrow and ncol functions. The resulting matrix is like the one in the previous example filled in by the columns. Since here we do not have the opportunity to use the byrow parameter, one of the ways to get a matrix filled by rows is to transpose the resulting result with the t function. m &lt;- t(m) # transpose the matrix and store it back in the variable `m` Finally, a matrix can be created by “gluing” rows and columns with the help of rbind andcbind. This is also a convenient way to add new rows and columns to an existing matrix. Exercise 3.16 - functions rbind and cbind a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0.0) # create a matrix `m` in which vectors `a` and `b` will be the columns # add a new row to the top of the matrix `m` with vector elements taken from`c` # print matrix `m` a &lt;- 1:4 b &lt;- 5:8 c &lt;- c(0.0) # create a matrix `m` in which vectors `a` and `b` will be columns m &lt;- cbind(a, b) # add a new row to the top of the matrix `m` with vector elements taken from`c` # print matrix `m` m &lt;- rbind(c, m) m ## a b ## c 0 0 ## 1 5 ## 2 6 ## 3 7 ## 4 8 3.3.1 Matrix slicing All the learned principles for “slicing” the vector using index vectors can be applied on matrices. The differences are as follows: we index each dimension individually first we index the rows, then the columns, dividing the index vectors with a , If we want “all rows” or “all columns” we simply omit the corresponding index vector(but keep the ,) Example 3.2 - matrix slicing # `m` is a 3 x 5 matrix , with column names from `a` to `e` m &lt;- matrix(1:15, nrow = 3, byrow = T) colnames(m) &lt;- letters[1:5] # note the function and the special R variable called &quot;letters&quot; m[1, 2:5] # first line, all columns from second to fifth m[c(F, T, T), c(&quot;a&quot;, &quot;b&quot;)] # second and third rows, columns `a` and` b` m[,] # all rows and all columns (same as just `m`) ## b c d e ## 2 3 4 5 ## a b ## [1,] 6 7 ## [2,] 11 12 ## a b c d e ## [1,] 1 2 3 4 5 ## [2,] 6 7 8 9 10 ## [3,] 11 12 13 14 15 In practice, the matrix usually uses a combination of positional and label-based indexing; conditional indexing is not too practical because of the two-dimensional nature of the matrix (although it is feasible, we just have to keep in mind that the lengths of logical vectors we use for indexing need to have the proper length of their corresponding dimension). One of the things we need to keep in mind is the R-language tendency to “help” us by simplifying the result. Thus, the result of a slicing operation that leaves only one row or column will automatically become a vector, i.e. it will lose the dim attribute. This is sometimes does not something we want, especially if we are working on scripts that expect a matrix further down the line, even if it has the dimension of rows or columns 1. In this case, we need to put an additional parameter drop = F after the index vectors. This is often somewhat unwieldy, which is why there are many R-language packages that “repair” this by offering the splicing functionality while keeping the result in a consistent format. Still, it’s useful to keep in mind the existence of the drop = FALSE option when there is danger that our programming script will fail if it gets a vector as a result instead of a one-dimensional matrix. Exercise 3.17 - matrix slicing m &lt;- matrix (1:30, 6, 5, T) colnames (m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # create a submatrix `m2` which contains everything from the second to the fourth row # and from the third to the fifth column # print `m2` # set all elements in column `c` of `m` to zero # and then print the first two rows of matrix `m` # print only column `d` from `m2` # print only column `d`, but add the `drop = FALSE` parameter when indexing # separate the parameter with a comma (as if it was a &quot;third&quot; indexing dimension) m &lt;- matrix (1:30, 6, 5, T) colnames(m) &lt;- c(&quot;a&quot;, &quot;b&quot;, &quot;c&quot;, &quot;d&quot;, &quot;e&quot;) # create a submatrix `m2` which contains everything from the second to the fourth row # and from the third to the fifth column # print `m2` m2 &lt;- m[2:4, 3:5] m2 # set all elements in column &quot;c&quot; to zero # and then print the first two lines of matrix `m` m[, &quot;c&quot;] &lt;- 0 m[1:2, ] # print only column `d` from `m` m[, &quot;d&quot;] # print only column `d`, but add the `drop = FALSE` parameter when indexing # separate the parameter with a comma (as if it was a &quot;third&quot; indexing dimension) m[, &quot;d&quot;, drop = F] ## c d e ## [1,] 8 9 10 ## [2,] 13 14 15 ## [3,] 18 19 20 ## a b c d e ## [1,] 1 2 0 4 5 ## [2,] 6 7 0 9 10 ## [1] 4 9 14 19 24 29 ## d ## [1,] 4 ## [2,] 9 ## [3,] 14 ## [4,] 19 ## [5,] 24 ## [6,] 29 We will end our overview of the matrices here. These data structures are very useful in solving various linear algebra problems. Additionally, some of the principles used for handling matrices will be useful when we soon introduce the “data frames” - one of the most useful data structures in R. Finally, although we will not extensively cover arrays, we will show an example of the program code that creates a three-dimensional array and then for element retrieval uses standard slicing principles we already learned with the vectors and matrices. myArray &lt;- array(1:24, dim = c(2, 3, 4)) # array of dimension 2 x 3 x 4 myArray[, 1:2, 3, drop = FALSE] # print all rows, first and second columns # 3rd &quot;layer,&quot; with array type retention 3.4 Lists In R lists are primarily used as a “universal data containers”. Unlike vectors (or better said the concept of a vector as we initially defined it), the list may contain different types of data or, more often, sets of different types of data. We can create a list with the list function to which we forward a string of names of elements and their contents as parameters. These elements can be anything, even other lists. myList &lt;- list(a = 1, b = 2:100, c = list(x = 1, y = 2)) Try to create your own list in the following example. Exercise 3.18 - list creation # create a new list called `stuff` that will have the following elements # element called `numbers&#39; with integers from 1 to 3 # element called `letters&#39; with letters &#39;A&#39; and &#39;B&#39; # nameless element with logical vector `c(T, F)` # element called `titles&#39; with the content: &quot;Mr&quot;, &quot;Mrs&quot; and &quot;Ms&quot; # print the `stuff` variable stuff &lt;- list(numbers = c(1,2,3), letters = c(&quot;A&quot;, &quot;B&quot;), c(T, F), titles = c(&quot;Mr&quot;, &quot;Mrs&quot;, &quot;Ms&quot;)) # print the `stuff` variable stuff ## $numbers ## [1] 1 2 3 ## ## $letters ## [1] &quot;A&quot; &quot;B&quot; ## ## [[3]] ## [1] TRUE FALSE ## ## $titles ## [1] &quot;Mr&quot; &quot;Mrs&quot; &quot;Ms&quot; Note that the list is an ordered data structure - the element without the name is shown in position 3. The str (“structure”) function allows us to inspect the properties and contents of a list contents without printing it in its entirety, which is very useful when we deal with large lists. This function is often used by data analysts, not only for lists but also for data frames, which will soon be introduced. Exercise 3.19 - list structure # print the structure of the `stuff` list # print the structure of the `stuff` list str(stuff) ## List of 4 ## $ numbers: num [1:3] 1 2 3 ## $ letters: chr [1:2] &quot;A&quot; &quot;B&quot; ## $ : logi [1:2] TRUE FALSE ## $ titles : chr [1:3] &quot;Mr&quot; &quot;Mrs&quot; &quot;Ms&quot; At the beginning of this lesson we said that one of the primary R principles is “everything is a vector”, where by vectors we mean arranged sets of elements of the same type. Initially it seems that list doesn’t conform to this principle, since it’s defining feature is the fact they may contain elements of different types. However, the surprising truth is in fact the opposite - the lists are actually vectors, and they actually do conform to the aforementioned definition. The answer to this enigma is actually rather simple - the list is in fact a recursive structure, and all the elements of the list are actually also (often small, single-element) lists, which means that formally all elements are truly of the same type. We can easily demonstrate this in the following exercise. Exercise 3.20 - list elements are lists # print the first element of the list `stuff` # check its class # print the first element of the list `stuff` stuff[1] # check its class class(stuff[1]) ## $numbers ## [1] 1 2 3 ## ## [1] &quot;list&quot; So, even though we assumed that the first element of the above list was a vector, we realized it’s actually a small list. This is often quite handy when we want to treat the list as a vector by using R functionality for vector management, however there are many cases where we do not want to work with a list element as a “small list”, but want to have it in its “original” simple vector form. To achieve this, we need to get rid of the list wrapper around the element. This can be done by using the operator [[, i.e. the “double angular brackets” operator. Exercise 3.21 - operator [[ # print the first element of the list `stuff` using the operator `[[` # check its class # print the first element of the list `stuff` using the operator `[[` stuff[[1]] # check its class class(stuff[[1]]) ## [1] 1 2 3 ## [1] &quot;numeric&quot; The aforementioned operator is most often used to retrieve the selected element by using its position in the list or its name (if defined). The second approach though is somewhat inconvenient, since we must use the syntax list[[name_element]] symbol, which is somewhat clumsy for typing since the element name also needs to be put in quotes. To make it easier to pull out elements by name, R offers an alternative way of accessing the list elements in this way bz leveraging the $ operator, i.e. using the syntax list$name_element (no quotes). Exercise 3.22 - operator $ # print the `letters` element of the `stuff` list # using `[[` the operator # print the `letters` element of the `stuff` list # using the `$` operator # print the `letters` element of the `stuff` list # using `[[` the operator stuff[[&quot;letters&quot;]] # print the `letters` element of the `stuff` list # using the `$` operator stuff$letters ## [1] &quot;A&quot; &quot;B&quot; ## [1] &quot;A&quot; &quot;B&quot; The lists are an extremely popular type of object in R, as they represent a universal template for more complex data structures, including more complex objects in the narrower sense (as we will see later). The list is also the “foundation” for the most popular and most commonly used element of the R-language: the data frame - which we will learn in the next chapter. Finally, we need to learn how to add an element to the list. The easiest way to do this is simply by using the aforementioned operator $ - we simply write something like list$newElement &lt;- newElementContents. In a similar fashion, we can delete a list element simply by assigning the NULL value to it. Exercise 3.23 - adding list elements # add the `evenNumbers` element to the `stuff` list which contains # all even numbers from 1 to 100 # delete the third element from this list # print the `stuff` list # in the `stuff` list add the `evenNumbers` element which contains # all even numbers from 1 to 100 stuff$evenNumbers &lt;- seq(2, 100, 2) # delete the third element from the list stuff[[3]] &lt;- NULL # print the `stuff` list print(stuff) ## $numbers ## [1] 1 2 3 ## ## $letters ## [1] &quot;A&quot; &quot;B&quot; ## ## $titles ## [1] &quot;Mr&quot; &quot;Mrs&quot; &quot;Ms&quot; ## ## $evenNumbers ## [1] 2 4 6 8 10 12 14 16 18 20 22 24 26 28 30 32 34 36 38 ## [20] 40 42 44 46 48 50 52 54 56 58 60 62 64 66 68 70 72 74 76 ## [39] 78 80 82 84 86 88 90 92 94 96 98 100 Homework exercises Create the following vectors: (11, 12, 13,…, 99) (0, 0, 0, 0, … , 0) (100 zeros) (0, 0.1, 0.2, …., 1.0) What is the sum of all numbers from 101 to 1001, if we skip all numbers divisible by 10? Use the sum function. Create a 3 x 3 matrix by performing the following commands (the sample function randomly picks elements from a provided vector; it will be covered in more detail in one of the following lessons): # we create a matrix of 3x3 randomly selected elements from 1 to 100 set.seed(1234) m &lt;- matrix(c(sample(1:100, 9, T)), nrow = 3, ncol = 3, byrow = T) Calculate the inverse matrix with the solve function. Make sure the multiplication of the original and inverse matrix result with the unit matrix (use the % *% operator to multiply the matrices). Initialize the stuff list used in the lesson. Do the following: print the class of the second element of the list print the element in the third place of the element of the list named letters check the length of the element called titles and add the title ‘Prof’ to the last position check if the number 4 is contained in the first element of the list add a new list of three vectors a,b and c which all contain elements (1,2,3) to the last place of the list, Program in Ru &lt;/ span&gt; by Damir Pintar is licensed under Creative Commons Attribution-NonCommercial-NoDerivative 4.0 International License Based on a work at https://ratnip.github.io/FER_OPJR/ "],["404.html", "Page not found", " Page not found The page you requested cannot be found (perhaps it was moved or renamed). You may want to try searching to find the page's new location, or use the table of contents to find the page you are looking for. "]]
